// ctrl + p then >Quokka.js: start on current file

/*Problem 1: Multiples of 3 or 5

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below the provided parameter value number.*/

function multiplesOf3Or5(number) {

    let sum = 0;

    for (let i = 1; i < number; i++) {
        if (i % 3 === 0 || i % 5 === 0) {
            sum += i;
        }
    }

    return sum;
}

console.log(multiplesOf3Or5(49));


/*Problem 2: Even Fibonacci Numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed n, find the sum of the even-valued terms.*/

function fiboEvenSum(n) {

    let prev = 1;
    let current = 2;
    let sum = 0;
    let sequence = []; //This was not required in the original exercise, but I wanted to compare something I explain below.

    while (current <= n) {
        if (current % 2 === 0) {
            sequence.push(current);
            sum += current; //As long I have "sequence" I could sum the Array's content, but this seems to be the simplest way, as I don´t need to go into another loop to go over "sequence".
        }

        const next = prev + current;
        prev = current;
        current = next;

    }

    return ("The sum of the sequence " + sequence + " is equal to " + sum);
}

console.log(fiboEvenSum(10));


/*Problem 3: Largest prime factor

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the given number?*/

/*The algorithm below is gonna work with small numbers, but it is gona stop executing with long numbers, because them need too much time to execute it*/

function largestPrimeFactor(number) {
    function isPrime(numero) {
        for (var i = 2; i < numero; i++) {
            if (numero % i === 0) {
                return false;
            }
        }
        return numero !== 1;
    }

    let largestPrime = 1;

    for (let i = number; i > 1; i--) {
        if (number % i === 0 && isPrime(i)) {
            largestPrime = i;
            break;
        }
    }

    return largestPrime;
}

console.log(largestPrimeFactor(80));

/*For the next algorithm I am apling this logic:
12/2 = 6
6/2 = 3
3 is not divisible by 2 so we sum 1 to the divider.
3/3 = 1 we reached 1 so it´s finished.
So the prime factors of 12 are 2, 3. And 3 is the largest prime factor.
*/

function largestPrimeFactorReview(n) {
    let divisor = 2;

    let number = n;

    while (number > 1) {
        if (number % divisor === 0) {
            number /= divisor;
        } else {
            divisor++
        }
    }
    return divisor;
}
/*This algorithm is much simple, faster and is gonna work with long numbers */
console.log(largestPrimeFactorReview(600851475143));


/*Problem 4: Largest palindrome product

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two n-digit numbers.*/

function largestPalindromeProduct(n) {

    function isPalindrome(num) {
        const strNum = num.toString();
        const reversedStr = strNum.split('').reverse().join('');
        return strNum === reversedStr;
    }

    const maxNumber = Math.pow(10, n) - 1; //maximo número de n cifras
    let largestPalindrome = 0;

    let n1 = 0;
    let n2 = 0;

    for (let i = maxNumber; i > 0; i--) {

        for (let j = i; j > 0; j--) {

            const product = i * j; //Is gonna multiplie all the posibilities beetween i and j

            if (isPalindrome(product) && product > largestPalindrome) {
                largestPalindrome = product;
                n1 = i;
                n2 = j;
            }
        }
    }

    return ("The largest palindrome made from the product of " + n + " digit numbers (" + n1 + "," + n2 + ") is " + largestPalindrome);
}

//This algorithm just works until 3, as long as 4 aready needs too much time to execute it.
console.log(largestPalindromeProduct(3));


/*Problem 5: Smallest multiple

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to n?*/

function smallestMult(n) {

    let result = 1;

    //Euclidean algorithm uses recursión to find the  greatest common divisor of two numbers.
    function gcd(a, b) {
        return b === 0 ? a : gcd(b, a % b);
    }

    // lcm uses this function to get the least common multiple of two numbers.
    function lcm(a, b) {
        return (a * b) / gcd(a, b);
    }

    //The fundamental property of lcm states that the lcm of a set of numbers is equal to the product of all the numbers divided by the gcd of those numbers. This property allows us to calculate the lcm of a set of numbers by taking two numbers at a time.
    for (let i = 2; i <= n; i++) {
        result = lcm(result, i);
    }

    return result;
}

console.log(smallestMult(4));


/*Problem 6: Sum square difference

The sum of the squares of the first ten natural numbers is,
12 + 22 + ... + 102 = 385

The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)2 = 552 = 3025

Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.

Find the difference between the sum of the squares of the first n natural numbers and the square of the sum.*/

function sumSquareDifference(n) {
    let sumSquares = 0;

    let sumNumbers = 0;

    for (let i = 1; i <= n; i++) {
        sumSquares += i * i;
        sumNumbers += i;
    }

    const difference = (sumNumbers * sumNumbers) - sumSquares;

    return difference;
}

console.log(sumSquareDifference(10));


/*Problem 7: 10001st prime

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the nth prime number?*/

function nthPrime(n) {

    function isPrime(numero) {
        for (var i = 2; i < numero; i++) {
            if (numero % i === 0) {
                return false;
            }
        }
        return numero !== 1;
    }

    let primeNumbers = [];


    for (let i = 1; primeNumbers.length < n; i++) {
        if (isPrime(i)) {
            primeNumbers.push(i);
        }

    }

    return primeNumbers[primeNumbers.length - 1];
}

console.log(nthPrime(6));



/*The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

Find the n adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?*/


function largestProductinaSeries(n) {

    let thousandDigits = [7, 3, 1, 6, 7, 1, 7, 6, 5, 3, 1, 3, 3, 0, 6, 2, 4, 9, 1, 9, 2, 2, 5, 1, 1, 9, 6, 7, 4, 4, 2, 6, 5, 7, 4, 7, 4, 2, 3, 5, 5, 3, 4, 9, 1, 9, 4, 9, 3, 4, 9, 6, 9, 8, 3, 5, 2, 0, 3, 1, 2, 7, 7, 4, 5, 0, 6, 3, 2, 6, 2, 3, 9, 5, 7, 8, 3, 1, 8, 0, 1, 6, 9, 8, 4, 8, 0, 1, 8, 6, 9, 4, 7, 8, 8, 5, 1, 8, 4, 3, 8, 5, 8, 6, 1, 5, 6, 0, 7, 8, 9, 1, 1, 2, 9, 4, 9, 4, 9, 5, 4, 5, 9, 5, 0, 1, 7, 3, 7, 9, 5, 8, 3, 3, 1, 9, 5, 2, 8, 5, 3, 2, 0, 8, 8, 0, 5, 5, 1, 1, 1, 2, 5, 4, 0, 6, 9, 8, 7, 4, 7, 1, 5, 8, 5, 2, 3, 8, 6, 3, 0, 5, 0, 7, 1, 5, 6, 9, 3, 2, 9, 0, 9, 6, 3, 2, 9, 5, 2, 2, 7, 4, 4, 3, 0, 4, 3, 5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5, 0, 4, 4, 5, 2, 4, 4, 5, 2, 3, 1, 6, 1, 7, 3, 1, 8, 5, 6, 4, 0, 3, 0, 9, 8, 7, 1, 1, 1, 2, 1, 7, 2, 2, 3, 8, 3, 1, 1, 3, 6, 2, 2, 2, 9, 8, 9, 3, 4, 2, 3, 3, 8, 0, 3, 0, 8, 1, 3, 5, 3, 3, 6, 2, 7, 6, 6, 1, 4, 2, 8, 2, 8, 0, 6, 4, 4, 4, 4, 8, 6, 6, 4, 5, 2, 3, 8, 7, 4, 9, 3, 0, 3, 5, 8, 9, 0, 7, 2, 9, 6, 2, 9, 0, 4, 9, 1, 5, 6, 0, 4, 4, 0, 7, 7, 2, 3, 9, 0, 7, 1, 3, 8, 1, 0, 5, 1, 5, 8, 5, 9, 3, 0, 7, 9, 6, 0, 8, 6, 6, 7, 0, 1, 7, 2, 4, 2, 7, 1, 2, 1, 8, 8, 3, 9, 9, 8, 7, 9, 7, 9, 0, 8, 7, 9, 2, 2, 7, 4, 9, 2, 1, 9, 0, 1, 6, 9, 9, 7, 2, 0, 8, 8, 8, 0, 9, 3, 7, 7, 6, 6, 5, 7, 2, 7, 3, 3, 3, 0, 0, 1, 0, 5, 3, 3, 6, 7, 8, 8, 1, 2, 2, 0, 2, 3, 5, 4, 2, 1, 8, 0, 9, 7, 5, 1, 2, 5, 4, 5, 4, 0, 5, 9, 4, 7, 5, 2, 2, 4, 3, 5, 2, 5, 8, 4, 9, 0, 7, 7, 1, 1, 6, 7, 0, 5, 5, 6, 0, 1, 3, 6, 0, 4, 8, 3, 9, 5, 8, 6, 4, 4, 6, 7, 0, 6, 3, 2, 4, 4, 1, 5, 7, 2, 2, 1, 5, 5, 3, 9, 7, 5, 3, 6, 9, 7, 8, 1, 7, 9, 7, 7, 8, 4, 6, 1, 7, 4, 0, 6, 4, 9, 5, 5, 1, 4, 9, 2, 9, 0, 8, 6, 2, 5, 6, 9, 3, 2, 1, 9, 7, 8, 4, 6, 8, 6, 2, 2, 4, 8, 2, 8, 3, 9, 7, 2, 2, 4, 1, 3, 7, 5, 6, 5, 7, 0, 5, 6, 0, 5, 7, 4, 9, 0, 2, 6, 1, 4, 0, 7, 9, 7, 2, 9, 6, 8, 6, 5, 2, 4, 1, 4, 5, 3, 5, 1, 0, 0, 4, 7, 4, 8, 2, 1, 6, 6, 3, 7, 0, 4, 8, 4, 4, 0, 3, 1, 9, 9, 8, 9, 0, 0, 0, 8, 8, 9, 5, 2, 4, 3, 4, 5, 0, 6, 5, 8, 5, 4, 1, 2, 2, 7, 5, 8, 8, 6, 6, 6, 8, 8, 1, 1, 6, 4, 2, 7, 1, 7, 1, 4, 7, 9, 9, 2, 4, 4, 4, 2, 9, 2, 8, 2, 3, 0, 8, 6, 3, 4, 6, 5, 6, 7, 4, 8, 1, 3, 9, 1, 9, 1, 2, 3, 1, 6, 2, 8, 2, 4, 5, 8, 6, 1, 7, 8, 6, 6, 4, 5, 8, 3, 5, 9, 1, 2, 4, 5, 6, 6, 5, 2, 9, 4, 7, 6, 5, 4, 5, 6, 8, 2, 8, 4, 8, 9, 1, 2, 8, 8, 3, 1, 4, 2, 6, 0, 7, 6, 9, 0, 0, 4, 2, 2, 4, 2, 1, 9, 0, 2, 2, 6, 7, 1, 0, 5, 5, 6, 2, 6, 3, 2, 1, 1, 1, 1, 1, 0, 9, 3, 7, 0, 5, 4, 4, 2, 1, 7, 5, 0, 6, 9, 4, 1, 6, 5, 8, 9, 6, 0, 4, 0, 8, 0, 7, 1, 9, 8, 4, 0, 3, 8, 5, 0, 9, 6, 2, 4, 5, 5, 4, 4, 4, 3, 6, 2, 9, 8, 1, 2, 3, 0, 9, 8, 7, 8, 7, 9, 9, 2, 7, 2, 4, 4, 2, 8, 4, 9, 0, 9, 1, 8, 8, 8, 4, 5, 8, 0, 1, 5, 6, 1, 6, 6, 0, 9, 7, 9, 1, 9, 1, 3, 3, 8, 7, 5, 4, 9, 9, 2, 0, 0, 5, 2, 4, 0, 6, 3, 6, 8, 9, 9, 1, 2, 5, 6, 0, 7, 1, 7, 6, 0, 6, 0, 5, 8, 8, 6, 1, 1, 6, 4, 6, 7, 1, 0, 9, 4, 0, 5, 0, 7, 7, 5, 4, 1, 0, 0, 2, 2, 5, 6, 9, 8, 3, 1, 5, 5, 2, 0, 0, 0, 5, 5, 9, 3, 5, 7, 2, 9, 7, 2, 5, 7, 1, 6, 3, 6, 2, 6, 9, 5, 6, 1, 8, 8, 2, 6, 7, 0, 4, 2, 8, 2, 5, 2, 4, 8, 3, 6, 0, 0, 8, 2, 3, 2, 5, 7, 5, 3, 0, 4, 2, 0, 7, 5, 2, 9, 6, 3, 4, 5, 0];

    let maxProduct = 0;

    for (let i = 0; i <= thousandDigits.length - n; i++) { //Iterate through each possible starting position while  there are still enough numbers to form a series of n digits. 
        let product = 1;
        for (let j = i; j < i + n; j++) { //Iterate through n adjacent digits starting from position i until i + n
            product *= thousandDigits[j]; //Multiply each  digit by the last product
        }
        if (product > maxProduct) {
            maxProduct = product; //At the end save the bigest product
        }
    }

    return maxProduct;
}

console.log(largestProductinaSeries(4));


/*Problem 9: Special Pythagorean triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
a∧2 + b∧2 = c∧2

For example, 3∧2 + 4∧2 = 9 + 16 = 25 = 5∧2.

There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc such that a + b + c = n.*/

function specialPythagoreanTriplet(n) {
    let sumOfabc = n;

    let product = 0;

    for (let a = 1; a < n; a++) {
        for (let b = a + 1; b < n; b++) {
            let c = n - a - b;
            if (a * a + b * b === c * c && a + b + c === sumOfabc) {
                product = a * b * c;
                return product
            }
        }
    }
    return "Could not find a Pythagorean triplet for the given number";
}

console.log(specialPythagoreanTriplet(1000));


/*Problem 10: Summation of primes

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below n.*/

function primeSummation(n) {

    function isPrime(numero) {
        for (var i = 2; i <= Math.sqrt(numero); i++) { //Here instead of using the square root I was using numero, but it made the function need too much time to execute, so I realized it was possible to make it faster by reducing the number of calculations 
            if (numero % i === 0) {
                return false;
            }
        }
        return numero !== 1;
    }

    let sum = 0;

    for (let i = 2; i < n; i++) {
        if (isPrime(i)) {
            sum += i
        }
    }

    return sum;
}

console.log(primeSummation(17));